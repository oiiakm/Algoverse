{"ast":null,"code":"// // Performs Dijkstra's algorithm; returns *all* nodes in the order\n// // in which they were visited. Also makes nodes point back to their\n// // previous node, effectively allowing us to compute the shortest path\n// // by backtracking from the finish node.\n// export function aStar(grid, startNode, finishNode) {\n//   const visitedNodesInOrder = [];\n//   startNode.distance = 0;\n//   const unvisitedNodes = getAllNodes(grid);\n//   while (!!unvisitedNodes.length) {\n//     sortNodesByDistance(unvisitedNodes,finishNode);\n//     const closestNode = unvisitedNodes.shift();\n//     // If we encounter a wall, we skip it.\n//     if (closestNode.isWall) continue;\n//     // If the closest node is at a distance of infinity,\n//     // we must be trapped and should therefore stop.\n//     if (closestNode.distance === Infinity) return visitedNodesInOrder;\n//     closestNode.isVisited = true;\n//     visitedNodesInOrder.push(closestNode);\n//     if (closestNode === finishNode) return visitedNodesInOrder;\n//     updateUnvisitedNeighbors(closestNode, grid);\n//   }\n// }\n\n// function sortNodesByDistance(unvisitedNodes,finishNode) {\n//   unvisitedNodes.sort((nodeA, nodeB) => (nodeA.distance+Math.abs(finishNode.row-nodeA.row)+Math.abs(finishNode.col-nodeA.col))\n//                                         - (nodeB.distance+Math.abs(finishNode.row-nodeB.row)+Math.abs(finishNode.col-nodeB.col)));\n// }\n\n// function updateUnvisitedNeighbors(node, grid) {\n//   const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n//   for (const neighbor of unvisitedNeighbors) {\n//     neighbor.distance = node.distance + 1;\n//     neighbor.previousNode = node;\n//   }\n// }\n\n// function getUnvisitedNeighbors(node, grid) {\n//   const neighbors = [];\n//   const {col, row} = node;\n//   if (row > 0) neighbors.push(grid[row - 1][col]);\n//   if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n//   if (col > 0) neighbors.push(grid[row][col - 1]);\n//   if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n//   return neighbors.filter(neighbor => !neighbor.isVisited);\n// }\n\n// function getAllNodes(grid) {\n//   const nodes = [];\n//   for (const row of grid) {\n//     for (const node of row) {\n//       nodes.push(node);\n//     }\n//   }\n//   return nodes;\n// }\n\n// // Backtracks from the finishNode to find the shortest path.\n// // Only works when called *after* the dijkstra method above.\n// export function getNodesInShortestPathOrder(finishNode) {\n//   const nodesInShortestPathOrder = [];\n//   let currentNode = finishNode;\n//   while (currentNode !== null) {\n//     nodesInShortestPathOrder.unshift(currentNode);\n//     currentNode = currentNode.previousNode;\n//   }\n//   return nodesInShortestPathOrder;\n// }","map":{"version":3,"names":[],"sources":["/Users/amit/Desktop/AlgorithmVisualizer-master/src/algorithms/Astar.js"],"sourcesContent":["// // Performs Dijkstra's algorithm; returns *all* nodes in the order\n// // in which they were visited. Also makes nodes point back to their\n// // previous node, effectively allowing us to compute the shortest path\n// // by backtracking from the finish node.\n// export function aStar(grid, startNode, finishNode) {\n//   const visitedNodesInOrder = [];\n//   startNode.distance = 0;\n//   const unvisitedNodes = getAllNodes(grid);\n//   while (!!unvisitedNodes.length) {\n//     sortNodesByDistance(unvisitedNodes,finishNode);\n//     const closestNode = unvisitedNodes.shift();\n//     // If we encounter a wall, we skip it.\n//     if (closestNode.isWall) continue;\n//     // If the closest node is at a distance of infinity,\n//     // we must be trapped and should therefore stop.\n//     if (closestNode.distance === Infinity) return visitedNodesInOrder;\n//     closestNode.isVisited = true;\n//     visitedNodesInOrder.push(closestNode);\n//     if (closestNode === finishNode) return visitedNodesInOrder;\n//     updateUnvisitedNeighbors(closestNode, grid);\n//   }\n// }\n\n// function sortNodesByDistance(unvisitedNodes,finishNode) {\n//   unvisitedNodes.sort((nodeA, nodeB) => (nodeA.distance+Math.abs(finishNode.row-nodeA.row)+Math.abs(finishNode.col-nodeA.col))\n//                                         - (nodeB.distance+Math.abs(finishNode.row-nodeB.row)+Math.abs(finishNode.col-nodeB.col)));\n// }\n\n// function updateUnvisitedNeighbors(node, grid) {\n//   const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n//   for (const neighbor of unvisitedNeighbors) {\n//     neighbor.distance = node.distance + 1;\n//     neighbor.previousNode = node;\n//   }\n// }\n\n// function getUnvisitedNeighbors(node, grid) {\n//   const neighbors = [];\n//   const {col, row} = node;\n//   if (row > 0) neighbors.push(grid[row - 1][col]);\n//   if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n//   if (col > 0) neighbors.push(grid[row][col - 1]);\n//   if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n//   return neighbors.filter(neighbor => !neighbor.isVisited);\n// }\n\n// function getAllNodes(grid) {\n//   const nodes = [];\n//   for (const row of grid) {\n//     for (const node of row) {\n//       nodes.push(node);\n//     }\n//   }\n//   return nodes;\n// }\n\n// // Backtracks from the finishNode to find the shortest path.\n// // Only works when called *after* the dijkstra method above.\n// export function getNodesInShortestPathOrder(finishNode) {\n//   const nodesInShortestPathOrder = [];\n//   let currentNode = finishNode;\n//   while (currentNode !== null) {\n//     nodesInShortestPathOrder.unshift(currentNode);\n//     currentNode = currentNode.previousNode;\n//   }\n//   return nodesInShortestPathOrder;\n// }\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module"}